{"ast":null,"code":"\"use strict\";\n\nconst {\n  addNwsapi\n} = require(\"../helpers/selectors\");\n\nconst {\n  HTML_NS\n} = require(\"../helpers/namespaces\");\n\nconst {\n  mixin,\n  memoizeQuery\n} = require(\"../../utils\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\n\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nconst attributes = require(\"../attributes\");\n\nconst namedPropertiesWindow = require(\"../named-properties-window\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  parseFragment\n} = require(\"../../browser/parser\");\n\nconst {\n  fragmentSerialization\n} = require(\"../domparsing/serialization\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst DOMException = require(\"domexception\");\n\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\n\nconst attrGenerated = require(\"../generated/Attr\");\n\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\n\nconst validateNames = require(\"../helpers/validate-names\");\n\nconst {\n  asciiLowercase\n} = require(\"../helpers/strings\");\n\nconst {\n  listOfElementsWithQualifiedName,\n  listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames\n} = require(\"../node\");\n\nconst SlotableMixinImpl = require(\"./Slotable-impl\").implementation;\n\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\n\nconst Text = require(\"../generated/Text\");\n\nconst {\n  isValidHostElementName\n} = require(\"../helpers/shadow-dom\");\n\nconst {\n  isValidCustomElementName\n} = require(\"../helpers/custom-elements\");\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._initSlotableMixin();\n\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n    this._namespaceURI = privateData.namespace || null;\n    this._prefix = null;\n    this._localName = privateData.localName;\n    this._shadowRoot = null;\n    this._attributeList = []; // Used for caching.\n\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl([], {\n      element: this\n    });\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n    const id = this.getAttributeNS(null, \"id\");\n\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n    const id = this.getAttributeNS(null, \"id\");\n\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    } // update classList\n\n\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n\n    this._attrModifiedSlotableMixin(name, value, oldValue);\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n\n  get prefix() {\n    return this._prefix;\n  }\n\n  get localName() {\n    return this._localName;\n  }\n\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n\n  get tagName() {\n    let qualifiedName = this._qualifiedName;\n\n    if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n\n    return qualifiedName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  } // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\n\n\n  get outerHTML() {\n    // TODO: maybe parse5 can give us a hook where it serializes the node itself too:\n    // https://github.com/inikulin/parse5/issues/230\n    // Alternatively, if we can create a virtual node in domSymbolTree, that'd also work.\n    // It's currently prevented by the fact that a node can't be duplicated in the same tree.\n    // Then we could get rid of all the code for childNodesForSerializing.\n    return fragmentSerialization({\n      childNodesForSerializing: [this],\n      _ownerDocument: this._ownerDocument\n    }, {\n      requireWellFormed: true\n    });\n  }\n\n  set outerHTML(markup) {\n    let parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      parent = document.createElementNS(HTML_NS, \"body\");\n    }\n\n    const fragment = parseFragment(markup, parent);\n    const contextObjectParent = domSymbolTree.parent(this);\n\n    contextObjectParent._replace(fragment, this);\n  } // https://w3c.github.io/DOM-Parsing/#dfn-innerhtml\n\n\n  get innerHTML() {\n    return fragmentSerialization(this, {\n      requireWellFormed: true\n    });\n  }\n\n  set innerHTML(markup) {\n    const fragment = parseFragment(markup, this);\n    let contextObject = this;\n\n    if (this.localName === \"template\" && this.namespaceURI === HTML_NS) {\n      contextObject = contextObject._templateContents;\n    }\n\n    contextObject._replaceAll(fragment);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl([], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = attrGenerated.createImpl([], {\n        localName: name,\n        value\n      });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(namespace, name); // Because of widespread use of this method internally, e.g. to manually implement attribute/content reflection, we\n    // centralize the conversion to a string here, so that all call sites don't have to do it.\n\n    value = `${value}`;\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  toggleAttribute(qualifiedName, force) {\n    validateNames.name(qualifiedName);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = asciiLowercase(qualifiedName);\n    }\n\n    const attribute = attributes.getAttributeByName(this, qualifiedName);\n\n    if (attribute === null) {\n      if (force === undefined || force === true) {\n        const newAttr = attrGenerated.createImpl([], {\n          localName: qualifiedName,\n          value: \"\"\n        });\n        attributes.appendAttribute(this, newAttr);\n        return true;\n      }\n\n      return false;\n    }\n\n    if (force === undefined || force === false) {\n      attributes.removeAttributeByName(this, qualifiedName);\n      return false;\n    }\n\n    return true;\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    if (!attributes.hasAttribute(this, attr)) {\n      throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n    } // eslint-disable-next-line no-restricted-properties\n\n\n    attributes.removeAttribute(this, attr);\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  } // https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\n  attachShadow(init) {\n    if (this.namespaceURI !== HTML_NS) {\n      throw new DOMException(\"This element does not support attachShadow. This element is not part of the HTML namespace.\", \"NotSupportedError\");\n    }\n\n    if (!isValidHostElementName(this.localName) && !isValidCustomElementName(this.localName)) {\n      const message = \"This element does not support attachShadow. This element is not a custom element nor \" + \"a standard element supporting a shadow root.\";\n      throw new DOMException(message, \"NotSupportedError\");\n    }\n\n    if (this._shadowRoot !== null) {\n      throw new DOMException(\"Shadow root cannot be created on a host which already hosts a shadow tree.\", \"InvalidStateError\");\n    }\n\n    const shadow = ShadowRoot.createImpl([], {\n      ownerDocument: this.ownerDocument,\n      mode: init.mode,\n      host: this\n    });\n    this._shadowRoot = shadow;\n    return shadow;\n  } // https://dom.spec.whatwg.org/#dom-element-shadowroot\n\n\n  get shadowRoot() {\n    const shadow = this._shadowRoot;\n\n    if (shadow === null || shadow.mode === \"closed\") {\n      return null;\n    }\n\n    return shadow;\n  } // https://dom.spec.whatwg.org/#insert-adjacent\n\n\n  _insertAdjacent(element, where, node) {\n    where = asciiLowercase(where);\n\n    if (where === \"beforebegin\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n\n      return element.parentNode._preInsert(node, element);\n    }\n\n    if (where === \"afterbegin\") {\n      return element._preInsert(node, element.firstChild);\n    }\n\n    if (where === \"beforeend\") {\n      return element._preInsert(node, null);\n    }\n\n    if (where === \"afterend\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n\n      return element.parentNode._preInsert(node, element.nextSibling);\n    }\n\n    throw new DOMException('Must provide one of \"beforebegin\", \"afterbegin\", ' + '\"beforeend\", or \"afterend\".', \"SyntaxError\");\n  }\n\n  insertAdjacentElement(where, element) {\n    return this._insertAdjacent(this, where, element);\n  }\n\n  insertAdjacentText(where, data) {\n    const text = Text.createImpl([], {\n      data,\n      ownerDocument: this._ownerDocument\n    });\n\n    this._insertAdjacent(this, where, text);\n  } // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n\n\n  insertAdjacentHTML(position, text) {\n    position = asciiLowercase(position);\n    let context;\n\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\":\n        {\n          context = this.parentNode;\n\n          if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n            throw new DOMException(\"Cannot insert HTML adjacent to \" + \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n          }\n\n          break;\n        }\n\n      case \"afterbegin\":\n      case \"beforeend\":\n        {\n          context = this;\n          break;\n        }\n\n      default:\n        {\n          throw new DOMException('Must provide one of \"beforebegin\", \"afterbegin\", ' + '\"beforeend\", or \"afterend\".', \"SyntaxError\");\n        }\n    }\n\n    if (context.nodeType !== NODE_TYPE.ELEMENT_NODE || context._ownerDocument._parsingMode === \"html\" && context._localName === \"html\" && context._namespaceURI === HTML_NS) {\n      context = context._ownerDocument.createElement(\"body\");\n    }\n\n    const fragment = parseFragment(text, context);\n\n    switch (position) {\n      case \"beforebegin\":\n        {\n          this.parentNode._insert(fragment, this);\n\n          break;\n        }\n\n      case \"afterbegin\":\n        {\n          this._insert(fragment, this.firstChild);\n\n          break;\n        }\n\n      case \"beforeend\":\n        {\n          this._append(fragment);\n\n          break;\n        }\n\n      case \"afterend\":\n        {\n          this.parentNode._insert(fragment, this.nextSibling);\n\n          break;\n        }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nmixin(ElementImpl.prototype, SlotableMixinImpl.prototype);\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = function (selectors) {\n  const matcher = addNwsapi(this);\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n};\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\nmodule.exports = {\n  implementation: ElementImpl\n};","map":{"version":3,"sources":["/Users/liamfink/class-app/node_modules/jsdom/lib/jsdom/living/nodes/Element-impl.js"],"names":["addNwsapi","require","HTML_NS","mixin","memoizeQuery","idlUtils","NodeImpl","implementation","ParentNodeImpl","ChildNodeImpl","attributes","namedPropertiesWindow","NODE_TYPE","parseFragment","fragmentSerialization","domSymbolTree","DOMException","DOMTokenList","attrGenerated","NamedNodeMap","validateNames","asciiLowercase","listOfElementsWithQualifiedName","listOfElementsWithNamespaceAndLocalName","listOfElementsWithClassNames","SlotableMixinImpl","NonDocumentTypeChildNode","ShadowRoot","Text","isValidHostElementName","isValidCustomElementName","attachId","id","elm","doc","_ids","push","detachId","elms","i","length","splice","ElementImpl","constructor","args","privateData","_initSlotableMixin","nodeType","ELEMENT_NODE","scrollTop","scrollLeft","_namespaceURI","namespace","_prefix","_localName","localName","_shadowRoot","_attributeList","_attributesByNameMap","Map","_attributes","createImpl","element","_attach","nodeAttachedToDocument","getAttributeNS","_ownerDocument","_detach","nodeDetachedFromDocument","_attrModified","name","value","oldValue","_modified","elementAttributeModified","_attached","_classList","undefined","attrModified","_attrModifiedSlotableMixin","namespaceURI","prefix","_qualifiedName","tagName","qualifiedName","_parsingMode","toUpperCase","outerHTML","childNodesForSerializing","requireWellFormed","markup","parent","document","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","createElementNS","fragment","contextObjectParent","_replace","innerHTML","contextObject","_templateContents","_replaceAll","classList","attributeLocalName","hasAttributes","getAttributeNames","attributeNames","getAttribute","attr","getAttributeByName","_value","getAttributeByNameNS","setAttribute","attribute","newAttr","appendAttribute","changeAttribute","setAttributeNS","extracted","validateAndExtract","setAttributeValue","removeAttribute","removeAttributeByName","removeAttributeNS","removeAttributeByNameNS","toggleAttribute","force","hasAttribute","hasAttributeByName","hasAttributeNS","hasAttributeByNameNS","getAttributeNode","getAttributeNodeNS","setAttributeNode","setAttributeNodeNS","removeAttributeNode","getBoundingClientRect","bottom","height","left","right","top","width","getClientRects","scrollWidth","scrollHeight","clientTop","clientLeft","clientWidth","clientHeight","attachShadow","init","message","shadow","ownerDocument","mode","host","shadowRoot","_insertAdjacent","where","node","parentNode","_preInsert","firstChild","nextSibling","insertAdjacentElement","insertAdjacentText","data","text","insertAdjacentHTML","position","context","createElement","_insert","_append","closest","selectors","matcher","wrapperForImpl","prototype","getElementsByTagName","getElementsByTagNameNS","getElementsByClassName","classNames","matches","match","webkitMatchesSelector","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst { addNwsapi } = require(\"../helpers/selectors\");\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { mixin, memoizeQuery } = require(\"../../utils\");\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\nconst attributes = require(\"../attributes\");\nconst namedPropertiesWindow = require(\"../named-properties-window\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { parseFragment } = require(\"../../browser/parser\");\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst DOMException = require(\"domexception\");\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\nconst attrGenerated = require(\"../generated/Attr\");\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\nconst validateNames = require(\"../helpers/validate-names\");\nconst { asciiLowercase } = require(\"../helpers/strings\");\nconst { listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames } = require(\"../node\");\nconst SlotableMixinImpl = require(\"./Slotable-impl\").implementation;\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\nconst Text = require(\"../generated/Text\");\nconst { isValidHostElementName } = require(\"../helpers/shadow-dom\");\nconst { isValidCustomElementName } = require(\"../helpers/custom-elements\");\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(args, privateData) {\n    super(args, privateData);\n\n    this._initSlotableMixin();\n\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this._namespaceURI = privateData.namespace || null;\n    this._prefix = null;\n    this._localName = privateData.localName;\n\n    this._shadowRoot = null;\n\n    this._attributeList = [];\n    // Used for caching.\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl([], {\n      element: this\n    });\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n\n    const id = this.getAttributeNS(null, \"id\");\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n\n    const id = this.getAttributeNS(null, \"id\");\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    }\n\n    // update classList\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n\n    this._attrModifiedSlotableMixin(name, value, oldValue);\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n  get prefix() {\n    return this._prefix;\n  }\n  get localName() {\n    return this._localName;\n  }\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n  get tagName() {\n    let qualifiedName = this._qualifiedName;\n    if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = qualifiedName.toUpperCase();\n    }\n    return qualifiedName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\n  get outerHTML() {\n    // TODO: maybe parse5 can give us a hook where it serializes the node itself too:\n    // https://github.com/inikulin/parse5/issues/230\n    // Alternatively, if we can create a virtual node in domSymbolTree, that'd also work.\n    // It's currently prevented by the fact that a node can't be duplicated in the same tree.\n    // Then we could get rid of all the code for childNodesForSerializing.\n    return fragmentSerialization({ childNodesForSerializing: [this], _ownerDocument: this._ownerDocument }, {\n      requireWellFormed: true\n    });\n  }\n  set outerHTML(markup) {\n    let parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      parent = document.createElementNS(HTML_NS, \"body\");\n    }\n\n    const fragment = parseFragment(markup, parent);\n\n    const contextObjectParent = domSymbolTree.parent(this);\n    contextObjectParent._replace(fragment, this);\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dfn-innerhtml\n  get innerHTML() {\n    return fragmentSerialization(this, { requireWellFormed: true });\n  }\n  set innerHTML(markup) {\n    const fragment = parseFragment(markup, this);\n\n    let contextObject = this;\n    if (this.localName === \"template\" && this.namespaceURI === HTML_NS) {\n      contextObject = contextObject._templateContents;\n    }\n\n    contextObject._replaceAll(fragment);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl([], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = attrGenerated.createImpl([], { localName: name, value });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(namespace, name);\n\n    // Because of widespread use of this method internally, e.g. to manually implement attribute/content reflection, we\n    // centralize the conversion to a string here, so that all call sites don't have to do it.\n    value = `${value}`;\n\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  toggleAttribute(qualifiedName, force) {\n    validateNames.name(qualifiedName);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = asciiLowercase(qualifiedName);\n    }\n\n    const attribute = attributes.getAttributeByName(this, qualifiedName);\n\n    if (attribute === null) {\n      if (force === undefined || force === true) {\n        const newAttr = attrGenerated.createImpl([], { localName: qualifiedName, value: \"\" });\n        attributes.appendAttribute(this, newAttr);\n        return true;\n      }\n      return false;\n    }\n\n    if (force === undefined || force === false) {\n      attributes.removeAttributeByName(this, qualifiedName);\n      return false;\n    }\n\n    return true;\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    if (!attributes.hasAttribute(this, attr)) {\n      throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n    }\n\n    // eslint-disable-next-line no-restricted-properties\n    attributes.removeAttribute(this, attr);\n\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-element-attachshadow\n  attachShadow(init) {\n    if (this.namespaceURI !== HTML_NS) {\n      throw new DOMException(\n        \"This element does not support attachShadow. This element is not part of the HTML namespace.\",\n        \"NotSupportedError\"\n      );\n    }\n\n    if (!isValidHostElementName(this.localName) && !isValidCustomElementName(this.localName)) {\n      const message = \"This element does not support attachShadow. This element is not a custom element nor \" +\n        \"a standard element supporting a shadow root.\";\n      throw new DOMException(message, \"NotSupportedError\");\n    }\n\n    if (this._shadowRoot !== null) {\n      throw new DOMException(\n        \"Shadow root cannot be created on a host which already hosts a shadow tree.\",\n        \"InvalidStateError\"\n      );\n    }\n\n    const shadow = ShadowRoot.createImpl([], {\n      ownerDocument: this.ownerDocument,\n      mode: init.mode,\n      host: this\n    });\n\n    this._shadowRoot = shadow;\n\n    return shadow;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-element-shadowroot\n  get shadowRoot() {\n    const shadow = this._shadowRoot;\n\n    if (shadow === null || shadow.mode === \"closed\") {\n      return null;\n    }\n\n    return shadow;\n  }\n\n  // https://dom.spec.whatwg.org/#insert-adjacent\n  _insertAdjacent(element, where, node) {\n    where = asciiLowercase(where);\n\n    if (where === \"beforebegin\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n      return element.parentNode._preInsert(node, element);\n    }\n    if (where === \"afterbegin\") {\n      return element._preInsert(node, element.firstChild);\n    }\n    if (where === \"beforeend\") {\n      return element._preInsert(node, null);\n    }\n    if (where === \"afterend\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n      return element.parentNode._preInsert(node, element.nextSibling);\n    }\n\n    throw new DOMException('Must provide one of \"beforebegin\", \"afterbegin\", ' +\n      '\"beforeend\", or \"afterend\".', \"SyntaxError\");\n  }\n\n  insertAdjacentElement(where, element) {\n    return this._insertAdjacent(this, where, element);\n  }\n\n  insertAdjacentText(where, data) {\n    const text = Text.createImpl([], { data, ownerDocument: this._ownerDocument });\n\n    this._insertAdjacent(this, where, text);\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n  insertAdjacentHTML(position, text) {\n    position = asciiLowercase(position);\n\n    let context;\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\": {\n        context = this.parentNode;\n        if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n          throw new DOMException(\"Cannot insert HTML adjacent to \" +\n            \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n        }\n        break;\n      }\n      case \"afterbegin\":\n      case \"beforeend\": {\n        context = this;\n        break;\n      }\n      default: {\n        throw new DOMException('Must provide one of \"beforebegin\", \"afterbegin\", ' +\n      '\"beforeend\", or \"afterend\".', \"SyntaxError\");\n      }\n    }\n\n    if (\n      context.nodeType !== NODE_TYPE.ELEMENT_NODE ||\n      (\n        context._ownerDocument._parsingMode === \"html\" &&\n        context._localName === \"html\" &&\n        context._namespaceURI === HTML_NS\n      )\n    ) {\n      context = context._ownerDocument.createElement(\"body\");\n    }\n\n    const fragment = parseFragment(text, context);\n\n    switch (position) {\n      case \"beforebegin\": {\n        this.parentNode._insert(fragment, this);\n        break;\n      }\n      case \"afterbegin\": {\n        this._insert(fragment, this.firstChild);\n        break;\n      }\n      case \"beforeend\": {\n        this._append(fragment);\n        break;\n      }\n      case \"afterend\": {\n        this.parentNode._insert(fragment, this.nextSibling);\n        break;\n      }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nmixin(ElementImpl.prototype, SlotableMixinImpl.prototype);\n\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = function (selectors) {\n  const matcher = addNwsapi(this);\n\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n};\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\n\nmodule.exports = {\n  implementation: ElementImpl\n};\n"]},"metadata":{},"sourceType":"script"}