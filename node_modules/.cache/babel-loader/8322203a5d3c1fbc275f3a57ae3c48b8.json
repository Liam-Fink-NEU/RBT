{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nconst Text = require(\"../../living/generated/Text\");\n\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\n\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nconst OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\n\nconst OpenElementStackOriginalPop = OpenElementStack.prototype.pop;\nconst OpenElementStackOriginalPush = OpenElementStack.prototype.push;\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285\n\n    this._currentElement = undefined; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n\n    const adapter = this;\n\n    OpenElementStack.prototype.push = function (...args) {\n      OpenElementStackOriginalPush.apply(this, args);\n      adapter._currentElement = this.current;\n      const after = this.items[this.stackTop];\n\n      if (after._pushedOnStackOfOpenElements) {\n        after._pushedOnStackOfOpenElements();\n      }\n    };\n\n    OpenElementStack.prototype.pop = function (...args) {\n      const before = this.items[this.stackTop];\n      OpenElementStackOriginalPop.apply(this, args);\n      adapter._currentElement = this.current;\n\n      if (before._poppedOffStackOfOpenElements) {\n        before._poppedOffStackOfOpenElements();\n      }\n    };\n  }\n\n  _ownerDocument() {\n    // The _currentElement is undefined when parsing elements at the root of the document. In this case we would\n    // fallback to the global _documentImpl.\n    return this._currentElement ? this._currentElement._ownerDocument : this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], {\n      ownerDocument: this._currentElement._ownerDocument\n    });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const element = ownerDocument._createElementWithCorrectElementInterface(localName, namespace);\n\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n\n    return Comment.createImpl([], {\n      data,\n      ownerDocument\n    });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const {\n      _ownerDocument,\n      _host\n    } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n\n    const documentType = DocumentType.createImpl([], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument\n    });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n} // Assign shared adapters with serializer.\n\n\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement._ownerDocument;\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"sources":["/Users/liamfink/class-app/node_modules/jsdom/lib/jsdom/browser/parser/html.js"],"names":["parse5","require","DocumentType","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","OpenElementStack","OpenElementStackOriginalPop","prototype","pop","OpenElementStackOriginalPush","push","JSDOMParse5Adapter","constructor","documentImpl","_documentImpl","_currentElement","undefined","adapter","args","apply","current","after","items","stackTop","_pushedOnStackOfOpenElements","before","_poppedOffStackOfOpenElements","_ownerDocument","createDocument","createDocumentFragment","createImpl","ownerDocument","createElement","localName","namespace","attrs","element","_createElementWithCorrectElementInterface","_namespaceURI","adoptAttributes","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","_append","insertBefore","referenceNode","_insert","setTemplateContent","templateElement","contentFragment","_host","_templateContents","setDocumentType","document","name","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","attr","prefix","setAttributeValue","value","Object","assign","parseFragment","markup","contextElement","config","_parseOptions","treeAdapter","parseIntoDocument","parse","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nconst OpenElementStack = require(\"parse5/lib/parser/open-element-stack\");\nconst OpenElementStackOriginalPop = OpenElementStack.prototype.pop;\nconst OpenElementStackOriginalPush = OpenElementStack.prototype.push;\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285\n    this._currentElement = undefined;\n\n    // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n    const adapter = this;\n    OpenElementStack.prototype.push = function (...args) {\n      OpenElementStackOriginalPush.apply(this, args);\n      adapter._currentElement = this.current;\n\n      const after = this.items[this.stackTop];\n      if (after._pushedOnStackOfOpenElements) {\n        after._pushedOnStackOfOpenElements();\n      }\n    };\n    OpenElementStack.prototype.pop = function (...args) {\n      const before = this.items[this.stackTop];\n\n      OpenElementStackOriginalPop.apply(this, args);\n      adapter._currentElement = this.current;\n\n      if (before._poppedOffStackOfOpenElements) {\n        before._poppedOffStackOfOpenElements();\n      }\n    };\n  }\n\n  _ownerDocument() {\n    // The _currentElement is undefined when parsing elements at the root of the document. In this case we would\n    // fallback to the global _documentImpl.\n    return this._currentElement ? this._currentElement._ownerDocument : this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], { ownerDocument: this._currentElement._ownerDocument });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const element = ownerDocument._createElementWithCorrectElementInterface(localName, namespace);\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl([], { data, ownerDocument });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const { _ownerDocument, _host } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl([], { name, publicId, systemId, ownerDocument });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl([], { data: text, ownerDocument });\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl([], { data: text, ownerDocument });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement._ownerDocument;\n\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = Object.assign({}, ownerDocument._parseOptions, {\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  });\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"]},"metadata":{},"sourceType":"script"}