{"ast":null,"code":"\"use strict\";\n\nconst {\n  SaxesParser\n} = require(\"saxes\");\n\nconst DOMException = require(\"domexception\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\n\nconst CDATASection = require(\"../../living/generated/CDATASection\");\n\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\n\nconst Text = require(\"../../living/generated/Text\");\n\nconst attributes = require(\"../../living/attributes\");\n\nconst {\n  HTML_NS\n} = require(\"../../living/helpers/namespaces\");\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentType(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentType(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(doc, namePiece, \"\", \"\");\n}\n\nfunction createDocumentType(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument,\n    name,\n    publicId,\n    systemId\n  });\n}\n\nfunction appendChild(parent, child) {\n  // Template elements do not have children but instead store their content in a separate hierarchy.\n  if (parent.tagName === \"template\" && parent.namespaceURI === HTML_NS) {\n    parent._templateContents._insert(child, null);\n  } else {\n    parent._insert(child, null);\n  }\n}\n\nfunction createParser(rootNode, ownerDocument, saxesOptions) {\n  const parser = new SaxesParser(saxesOptions);\n  const openStack = [rootNode];\n  parser.ontext = saxesOptions.fragment ? // In a fragment, all text events produced by saxes must result in a text\n  // node.\n  data => {\n    appendChild(openStack[openStack.length - 1], Text.createImpl([], {\n      data,\n      ownerDocument\n    }));\n  } : // When parsing a whole document, we must ignore those text nodes that are\n  // produced outside the root element. Saxes produces events for them,\n  // but DOM trees do not record text outside the root element.\n  data => {\n    if (openStack.length > 1) {\n      appendChild(openStack[openStack.length - 1], Text.createImpl([], {\n        data,\n        ownerDocument\n      }));\n    }\n  };\n\n  parser.oncdata = data => {\n    appendChild(openStack[openStack.length - 1], CDATASection.createImpl([], {\n      data,\n      ownerDocument\n    }));\n  };\n\n  parser.onopentag = tag => {\n    const {\n      local: tagLocal,\n      uri: tagURI,\n      prefix: tagPrefix,\n      attributes: tagAttributes\n    } = tag;\n\n    const elem = ownerDocument._createElementWithCorrectElementInterface(tagLocal, tagURI);\n\n    elem._prefix = tagPrefix || null;\n    elem._namespaceURI = tagURI || null; // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n\n    if (tagLocal === \"script\" && tagURI === HTML_NS) {\n      elem._parserInserted = true;\n    }\n\n    for (const key of Object.keys(tagAttributes)) {\n      const {\n        prefix,\n        local,\n        uri,\n        value\n      } = tagAttributes[key];\n      attributes.setAttributeValue(elem, local, value, prefix === \"\" ? null : prefix, uri === \"\" ? null : uri);\n    }\n\n    appendChild(openStack[openStack.length - 1], elem);\n    openStack.push(elem);\n  };\n\n  parser.onclosetag = () => {\n    const elem = openStack.pop(); // Once a script is populated, we can execute it.\n\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  };\n\n  parser.oncomment = data => {\n    appendChild(openStack[openStack.length - 1], Comment.createImpl([], {\n      data,\n      ownerDocument\n    }));\n  };\n\n  parser.onprocessinginstruction = ({\n    target,\n    body\n  }) => {\n    appendChild(openStack[openStack.length - 1], ProcessingInstruction.createImpl([], {\n      target,\n      data: body,\n      ownerDocument\n    }));\n  };\n\n  parser.ondoctype = dt => {\n    appendChild(openStack[openStack.length - 1], parseDocType(ownerDocument, `<!doctype ${dt}>`));\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    let result;\n\n    while (result = entityMatcher.exec(dt)) {\n      const [, name, value] = result;\n\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  };\n\n  parser.onerror = err => {\n    throw new DOMException(err.message, \"SyntaxError\");\n  };\n\n  return parser;\n}\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement._ownerDocument;\n  const fragment = DocumentFragment.createImpl([], {\n    ownerDocument\n  }); // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n\n  const parser = createParser(fragment, ownerDocument, {\n    xmlns: true,\n    fragment: true,\n\n    resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n\n  });\n  parser.write(markup).close();\n  return fragment;\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const parser = createParser(ownerDocument, ownerDocument, {\n    xmlns: true\n  });\n  parser.write(markup).close();\n  return ownerDocument;\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"sources":["/Users/liamfink/class-app/node_modules/jsdom/lib/jsdom/browser/parser/xml.js"],"names":["SaxesParser","require","DOMException","DocumentFragment","DocumentType","CDATASection","Comment","ProcessingInstruction","Text","attributes","HTML_NS","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","CUSTOM_NAME_DOCTYPE","parseDocType","doc","html","test","createDocumentType","publicPieces","exec","systemPieces","namePiece","ownerDocument","name","publicId","systemId","createImpl","appendChild","parent","child","tagName","namespaceURI","_templateContents","_insert","createParser","rootNode","saxesOptions","parser","openStack","ontext","fragment","data","length","oncdata","onopentag","tag","local","tagLocal","uri","tagURI","prefix","tagPrefix","tagAttributes","elem","_createElementWithCorrectElementInterface","_prefix","_namespaceURI","_parserInserted","key","Object","keys","value","setAttributeValue","push","onclosetag","pop","localName","_eval","oncomment","onprocessinginstruction","target","body","ondoctype","dt","entityMatcher","result","ENTITIES","onerror","err","message","parseFragment","markup","contextElement","_ownerDocument","xmlns","resolvePrefix","lookupNamespaceURI","undefined","write","close","parseIntoDocument","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst { SaxesParser } = require(\"saxes\");\nconst DOMException = require(\"domexception\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst CDATASection = require(\"../../living/generated/CDATASection\");\nconst Comment = require(\"../../living/generated/Comment\");\nconst ProcessingInstruction = require(\"../../living/generated/ProcessingInstruction\");\nconst Text = require(\"../../living/generated/Text\");\n\nconst attributes = require(\"../../living/attributes\");\nconst { HTML_NS } = require(\"../../living/helpers/namespaces\");\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nconst CUSTOM_NAME_DOCTYPE = /<!doctype\\s+([^\\s>]+)/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentType(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentType(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentType(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  const namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || \"html\";\n  return createDocumentType(doc, namePiece, \"\", \"\");\n}\n\nfunction createDocumentType(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { ownerDocument, name, publicId, systemId });\n}\n\nfunction appendChild(parent, child) {\n  // Template elements do not have children but instead store their content in a separate hierarchy.\n  if (parent.tagName === \"template\" && parent.namespaceURI === HTML_NS) {\n    parent._templateContents._insert(child, null);\n  } else {\n    parent._insert(child, null);\n  }\n}\n\nfunction createParser(rootNode, ownerDocument, saxesOptions) {\n  const parser = new SaxesParser(saxesOptions);\n  const openStack = [rootNode];\n\n  parser.ontext = saxesOptions.fragment ?\n    // In a fragment, all text events produced by saxes must result in a text\n    // node.\n    data => {\n      appendChild(\n        openStack[openStack.length - 1],\n        Text.createImpl([], { data, ownerDocument })\n      );\n    } :\n    // When parsing a whole document, we must ignore those text nodes that are\n    // produced outside the root element. Saxes produces events for them,\n    // but DOM trees do not record text outside the root element.\n    data => {\n      if (openStack.length > 1) {\n        appendChild(\n          openStack[openStack.length - 1],\n          Text.createImpl([], { data, ownerDocument })\n        );\n      }\n    };\n\n  parser.oncdata = data => {\n    appendChild(\n      openStack[openStack.length - 1],\n      CDATASection.createImpl([], { data, ownerDocument })\n    );\n  };\n\n  parser.onopentag = tag => {\n    const { local: tagLocal, uri: tagURI, prefix: tagPrefix, attributes: tagAttributes } = tag;\n\n    const elem = ownerDocument._createElementWithCorrectElementInterface(tagLocal, tagURI);\n\n    elem._prefix = tagPrefix || null;\n    elem._namespaceURI = tagURI || null;\n\n    // We mark a script element as \"parser-inserted\", which prevents it from\n    // being immediately executed.\n    if (tagLocal === \"script\" && tagURI === HTML_NS) {\n      elem._parserInserted = true;\n    }\n\n    for (const key of Object.keys(tagAttributes)) {\n      const { prefix, local, uri, value } = tagAttributes[key];\n      attributes.setAttributeValue(\n        elem, local, value, prefix === \"\" ? null : prefix,\n        uri === \"\" ? null : uri\n      );\n    }\n\n    appendChild(\n      openStack[openStack.length - 1],\n      elem\n    );\n    openStack.push(elem);\n  };\n\n  parser.onclosetag = () => {\n    const elem = openStack.pop();\n    // Once a script is populated, we can execute it.\n    if (elem.localName === \"script\" && elem.namespaceURI === HTML_NS) {\n      elem._eval();\n    }\n  };\n\n  parser.oncomment = data => {\n    appendChild(\n      openStack[openStack.length - 1],\n      Comment.createImpl([], { data, ownerDocument })\n    );\n  };\n\n  parser.onprocessinginstruction = ({ target, body }) => {\n    appendChild(\n      openStack[openStack.length - 1],\n      ProcessingInstruction.createImpl([], { target, data: body, ownerDocument })\n    );\n  };\n\n  parser.ondoctype = dt => {\n    appendChild(\n      openStack[openStack.length - 1],\n      parseDocType(ownerDocument, `<!doctype ${dt}>`)\n    );\n\n    const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n    let result;\n    while ((result = entityMatcher.exec(dt))) {\n      const [, name, value] = result;\n      if (!(name in parser.ENTITIES)) {\n        parser.ENTITIES[name] = value;\n      }\n    }\n  };\n\n  parser.onerror = err => {\n    throw new DOMException(err.message, \"SyntaxError\");\n  };\n\n  return parser;\n}\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement._ownerDocument;\n  const fragment = DocumentFragment.createImpl([], { ownerDocument });\n\n  // Only parseFragment needs resolvePrefix per the saxes documentation:\n  // https://github.com/lddubeau/saxes#parsing-xml-fragments\n  const parser = createParser(fragment, ownerDocument, {\n    xmlns: true,\n    fragment: true,\n    resolvePrefix(prefix) {\n      // saxes wants undefined as the return value if the prefix is not defined, not null.\n      return contextElement.lookupNamespaceURI(prefix) || undefined;\n    }\n  });\n\n  parser.write(markup).close();\n\n  return fragment;\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const parser = createParser(ownerDocument, ownerDocument, {\n    xmlns: true\n  });\n\n  parser.write(markup).close();\n\n  return ownerDocument;\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"]},"metadata":{},"sourceType":"script"}