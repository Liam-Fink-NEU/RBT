{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst {\n  isNode,\n  isShadowRoot,\n  isSlotable,\n  getRoot,\n  getEventTargetParent,\n  isShadowInclusiveAncestor,\n  retarget\n} = require(\"../helpers/shadow-dom\");\n\nconst Event = require(\"../generated/Event\").interface;\n\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n    return this._dispatch(eventImpl);\n  } // https://dom.spec.whatwg.org/#get-the-parent\n\n\n  _getTheParent() {\n    return null;\n  } // https://dom.spec.whatwg.org/#concept-event-dispatch\n  // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n\n\n  _dispatch(eventImpl, targetOverride\n  /* , legacyOutputDidListenersThrowFlag */\n  ) {\n    let targetImpl = this;\n    let clearTargets = false;\n    let activationTarget = null;\n    eventImpl._dispatchFlag = true;\n    targetOverride = targetOverride || targetImpl;\n    let relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n    if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n      const touchTargets = [];\n      appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n      const isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n      if (isActivationEvent && targetImpl._hasActivationBehavior) {\n        activationTarget = targetImpl;\n      }\n\n      let slotInClosedTree = false;\n      let slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n      let parent = getEventTargetParent(targetImpl, eventImpl); // Populate event path\n      // https://dom.spec.whatwg.org/#event-path\n\n      while (parent !== null) {\n        if (slotable !== null) {\n          if (parent.localName !== \"slot\") {\n            throw new Error(`JSDOM Internal Error: Expected parent to be a Slot`);\n          }\n\n          slotable = null;\n          const parentRoot = getRoot(parent);\n\n          if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n            slotInClosedTree = true;\n          }\n        }\n\n        if (isSlotable(parent) && parent._assignedSlot) {\n          slotable = parent;\n        }\n\n        relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n        if (isNode(parent) && isShadowInclusiveAncestor(getRoot(targetImpl), parent) || idlUtils.wrapperForImpl(parent).constructor.name === \"Window\") {\n          if (isActivationEvent && eventImpl.bubbles && activationTarget === null && parent._hasActivationBehavior) {\n            activationTarget = parent;\n          }\n\n          appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n        } else if (parent === relatedTarget) {\n          parent = null;\n        } else {\n          targetImpl = parent;\n\n          if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n            activationTarget = targetImpl;\n          }\n\n          appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n        }\n\n        if (parent !== null) {\n          parent = getEventTargetParent(parent, eventImpl);\n        }\n\n        slotInClosedTree = false;\n      }\n\n      let clearTargetsTupleIndex = -1;\n\n      for (let i = eventImpl._path.length - 1; i >= 0 && clearTargetsTupleIndex === -1; i--) {\n        if (eventImpl._path[i].target !== null) {\n          clearTargetsTupleIndex = i;\n        }\n      }\n\n      const clearTargetsTuple = eventImpl._path[clearTargetsTupleIndex];\n      clearTargets = isNode(clearTargetsTuple.target) && isShadowRoot(getRoot(clearTargetsTuple.target)) || isNode(clearTargetsTuple.relatedTarget) && isShadowRoot(getRoot(clearTargetsTuple.relatedTarget));\n      eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n        activationTarget._legacyPreActivationBehavior();\n      }\n\n      for (let i = eventImpl._path.length - 1; i >= 0; --i) {\n        const tuple = eventImpl._path[i];\n\n        if (tuple.target === null) {\n          invokeEventListeners(tuple, eventImpl);\n        }\n      }\n\n      for (let i = 0; i < eventImpl._path.length; i++) {\n        const tuple = eventImpl._path[i];\n\n        if (tuple.target !== null) {\n          eventImpl.eventPhase = Event.AT_TARGET;\n        } else {\n          eventImpl.eventPhase = Event.BUBBLING_PHASE;\n        }\n\n        if (eventImpl.eventPhase === Event.BUBBLING_PHASE && eventImpl.bubbles || eventImpl.eventPhase === Event.AT_TARGET) {\n          invokeEventListeners(tuple, eventImpl);\n        }\n      }\n    }\n\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    eventImpl._path = [];\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n\n    if (clearTargets) {\n      eventImpl.target = null;\n      eventImpl.relatedTarget = null;\n    }\n\n    if (activationTarget !== null) {\n      if (!eventImpl._canceledFlag) {\n        activationTarget._activationBehavior();\n      } else if (activationTarget._legacyCanceledActivationBehavior) {\n        activationTarget._legacyCanceledActivationBehavior();\n      }\n    }\n\n    return !eventImpl._canceledFlag;\n  }\n\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n}; // https://dom.spec.whatwg.org/#concept-event-listener-invoke\n\nfunction invokeEventListeners(tuple, eventImpl) {\n  const tupleIndex = eventImpl._path.indexOf(tuple);\n\n  for (let i = tupleIndex; i >= 0; i--) {\n    const t = eventImpl._path[i];\n\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(tuple.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(tuple.item);\n  const listeners = tuple.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners);\n} // https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\n\n\nfunction innerInvokeEventListeners(eventImpl, listeners) {\n  let found = false;\n  const {\n    type,\n    target\n  } = eventImpl;\n  const wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  } // Copy event listeners before iterating since the list can be modified during the iteration.\n\n\n  const handlers = listeners[type].slice();\n\n  for (let i = 0; i < handlers.length; i++) {\n    const listener = handlers[i];\n    const {\n      capture,\n      once,\n      passive\n    } = listener.options; // Check if the event listener has been removed since the listeners has been cloned.\n\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(eventImpl.currentTarget, idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n} // https://dom.spec.whatwg.org/#concept-event-path-append\n\n\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  const itemInShadowTree = isNode(target) && isShadowRoot(getRoot(target));\n  const rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree,\n    target: targetOverride,\n    relatedTarget,\n    touchTargets,\n    rootOfClosedTree,\n    slotInClosedTree\n  });\n}","map":{"version":3,"sources":["/Users/liamfink/class-app/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"names":["DOMException","require","reportException","idlUtils","isNode","isShadowRoot","isSlotable","getRoot","getEventTargetParent","isShadowInclusiveAncestor","retarget","Event","interface","MouseEvent","EventTargetImpl","constructor","_eventListeners","Object","create","addEventListener","type","callback","options","undefined","TypeError","normalizeEventHandlerOptions","i","length","listener","capture","push","removeEventListener","splice","dispatchEvent","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","NONE","isTrusted","_dispatch","_getTheParent","targetOverride","targetImpl","clearTargets","activationTarget","relatedTarget","touchTargets","appendToEventPath","isActivationEvent","isImpl","_hasActivationBehavior","slotInClosedTree","slotable","_assignedSlot","parent","localName","Error","parentRoot","mode","wrapperForImpl","name","bubbles","clearTargetsTupleIndex","_path","target","clearTargetsTuple","CAPTURING_PHASE","_legacyPreActivationBehavior","tuple","invokeEventListeners","AT_TARGET","BUBBLING_PHASE","currentTarget","_stopPropagationFlag","_stopImmediatePropagationFlag","_canceledFlag","_activationBehavior","_legacyCanceledActivationBehavior","module","exports","implementation","tupleIndex","indexOf","t","item","listeners","innerInvokeEventListeners","found","wrapper","handlers","slice","once","passive","includes","_inPassiveListenerFlag","handleEvent","call","e","window","_document","_ownerDocument","_defaultView","defaultBoolKeys","returnValue","Boolean","filter","k","key","itemInShadowTree","rootOfClosedTree"],"mappings":"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","sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst idlUtils = require(\"../generated/utils\");\nconst {\n  isNode, isShadowRoot, isSlotable, getRoot, getEventTargetParent,\n  isShadowInclusiveAncestor, retarget\n} = require(\"../helpers/shadow-dom\");\n\nconst Event = require(\"../generated/Event\").interface;\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#get-the-parent\n  _getTheParent() {\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-event-dispatch\n  // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n  _dispatch(eventImpl, targetOverride /* , legacyOutputDidListenersThrowFlag */) {\n    let targetImpl = this;\n    let clearTargets = false;\n    let activationTarget = null;\n\n    eventImpl._dispatchFlag = true;\n\n    targetOverride = targetOverride || targetImpl;\n    let relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n    if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n      const touchTargets = [];\n\n      appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n\n      const isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n      if (isActivationEvent && targetImpl._hasActivationBehavior) {\n        activationTarget = targetImpl;\n      }\n\n      let slotInClosedTree = false;\n      let slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n      let parent = getEventTargetParent(targetImpl, eventImpl);\n\n      // Populate event path\n      // https://dom.spec.whatwg.org/#event-path\n      while (parent !== null) {\n        if (slotable !== null) {\n          if (parent.localName !== \"slot\") {\n            throw new Error(`JSDOM Internal Error: Expected parent to be a Slot`);\n          }\n\n          slotable = null;\n\n          const parentRoot = getRoot(parent);\n          if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n            slotInClosedTree = true;\n          }\n        }\n\n        if (isSlotable(parent) && parent._assignedSlot) {\n          slotable = parent;\n        }\n\n        relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n        if (\n          (isNode(parent) && isShadowInclusiveAncestor(getRoot(targetImpl), parent)) ||\n          idlUtils.wrapperForImpl(parent).constructor.name === \"Window\"\n        ) {\n          if (isActivationEvent && eventImpl.bubbles && activationTarget === null &&\n              parent._hasActivationBehavior) {\n            activationTarget = parent;\n          }\n\n          appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n        } else if (parent === relatedTarget) {\n          parent = null;\n        } else {\n          targetImpl = parent;\n\n          if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n            activationTarget = targetImpl;\n          }\n\n          appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n        }\n\n        if (parent !== null) {\n          parent = getEventTargetParent(parent, eventImpl);\n        }\n\n        slotInClosedTree = false;\n      }\n\n      let clearTargetsTupleIndex = -1;\n      for (let i = eventImpl._path.length - 1; i >= 0 && clearTargetsTupleIndex === -1; i--) {\n        if (eventImpl._path[i].target !== null) {\n          clearTargetsTupleIndex = i;\n        }\n      }\n      const clearTargetsTuple = eventImpl._path[clearTargetsTupleIndex];\n\n      clearTargets =\n          (isNode(clearTargetsTuple.target) && isShadowRoot(getRoot(clearTargetsTuple.target))) ||\n          (isNode(clearTargetsTuple.relatedTarget) && isShadowRoot(getRoot(clearTargetsTuple.relatedTarget)));\n\n      eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n        activationTarget._legacyPreActivationBehavior();\n      }\n\n      for (let i = eventImpl._path.length - 1; i >= 0; --i) {\n        const tuple = eventImpl._path[i];\n\n        if (tuple.target === null) {\n          invokeEventListeners(tuple, eventImpl);\n        }\n      }\n\n      for (let i = 0; i < eventImpl._path.length; i++) {\n        const tuple = eventImpl._path[i];\n\n        if (tuple.target !== null) {\n          eventImpl.eventPhase = Event.AT_TARGET;\n        } else {\n          eventImpl.eventPhase = Event.BUBBLING_PHASE;\n        }\n\n        if (\n          (eventImpl.eventPhase === Event.BUBBLING_PHASE && eventImpl.bubbles) ||\n          eventImpl.eventPhase === Event.AT_TARGET\n        ) {\n          invokeEventListeners(tuple, eventImpl);\n        }\n      }\n    }\n\n    eventImpl.eventPhase = Event.NONE;\n\n    eventImpl.currentTarget = null;\n    eventImpl._path = [];\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n\n    if (clearTargets) {\n      eventImpl.target = null;\n      eventImpl.relatedTarget = null;\n    }\n\n    if (activationTarget !== null) {\n      if (!eventImpl._canceledFlag) {\n        activationTarget._activationBehavior();\n      } else if (activationTarget._legacyCanceledActivationBehavior) {\n        activationTarget._legacyCanceledActivationBehavior();\n      }\n    }\n\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\n// https://dom.spec.whatwg.org/#concept-event-listener-invoke\nfunction invokeEventListeners(tuple, eventImpl) {\n  const tupleIndex = eventImpl._path.indexOf(tuple);\n  for (let i = tupleIndex; i >= 0; i--) {\n    const t = eventImpl._path[i];\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(tuple.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(tuple.item);\n\n  const listeners = tuple.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners);\n}\n\n// https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\nfunction innerInvokeEventListeners(eventImpl, listeners) {\n  let found = false;\n\n  const { type, target } = eventImpl;\n  const wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  }\n\n  // Copy event listeners before iterating since the list can be modified during the iteration.\n  const handlers = listeners[type].slice();\n\n  for (let i = 0; i < handlers.length; i++) {\n    const listener = handlers[i];\n    const { capture, once, passive } = listener.options;\n\n    // Check if the event listener has been removed since the listeners has been cloned.\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (\n      (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n      (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)\n    ) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(eventImpl.currentTarget, idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n\n// https://dom.spec.whatwg.org/#concept-event-path-append\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  const itemInShadowTree = isNode(target) && isShadowRoot(getRoot(target));\n  const rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree,\n    target: targetOverride,\n    relatedTarget,\n    touchTargets,\n    rootOfClosedTree,\n    slotInClosedTree\n  });\n}\n"]},"metadata":{},"sourceType":"script"}